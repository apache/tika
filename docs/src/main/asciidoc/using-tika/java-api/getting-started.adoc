//
// Licensed to the Apache Software Foundation (ASF) under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// The ASF licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

= Getting Started with the Java API

== Before You Start

Before embedding Tika directly in your Java application, consider whether a
client-server architecture would better suit your needs.

=== Recommended: Use tika-server or tika-grpc

For most use cases, we recommend running Tika as a separate service rather than
embedding it directly:

* **link:../server/index.html[tika-server]** - REST API, language-agnostic
* **link:../grpc/index.html[tika-grpc]** - High-performance gRPC protocol

**Why?**

* **Process isolation** - Parser crashes don't affect your application
* **Easier deployment** - Use official Docker images
* **Language flexibility** - Call from any language, not just Java
* **Simpler upgrades** - Update Tika independently of your application

Docker images are available at https://hub.docker.com/r/apache/tika[Docker Hub].

=== When to Use the Java API

The Java API is appropriate when you:

* Need tight integration with Tika internals
* Cannot use a network service
* Have specific customization requirements

== Using PipesForkParser (Recommended)

If you must use Tika as a library, use `PipesForkParser` from the
`tika-pipes-fork-parser` module. It provides process isolation to protect your
application from parser crashes, memory leaks, and infinite loops.

=== Maven Dependency

[source,xml]
----
<dependency>
    <groupId>org.apache.tika</groupId>
    <artifactId>tika-pipes-fork-parser</artifactId>
    <version>${tika.version}</version>
</dependency>
----

=== Basic Example

[source,java]
----
import org.apache.tika.io.TikaInputStream;
import org.apache.tika.pipes.fork.PipesForkParser;
import org.apache.tika.pipes.fork.PipesForkResult;

try (PipesForkParser parser = new PipesForkParser();
     TikaInputStream tis = TikaInputStream.get(filePath)) {

    PipesForkResult result = parser.parse(tis);

    if (result.isSuccess()) {
        String content = result.getContent();
        // process content...
    } else {
        // handle failure
    }
}
----

=== Key Features

* **Process isolation** - Parsing runs in a separate JVM
* **Automatic restart** - If the forked process crashes, it restarts automatically
* **Configurable timeouts** - Prevent infinite loops
* **Thread-safe** - Reuse across multiple threads

=== Complete Examples

See
https://github.com/apache/tika/blob/main/tika-example/src/main/java/org/apache/tika/example/PipesForkParserExample.java[PipesForkParserExample.java]
in the `tika-example` module for comprehensive examples including:

* Basic parsing
* Handling embedded documents
* Custom configuration
* Error handling
* Batch processing

== Without Pipes: Understanding the Risks

If you choose not to use `PipesForkParser` and instead use Tika's parsers directly
(e.g., `AutoDetectParser`), you are responsible for handling the risks of parsing
untrusted content.

WARNING: Running parsers directly on untrusted data can cause OutOfMemoryErrors,
infinite loops, and crashes that will affect your entire application.

Before proceeding without process isolation, read:

* link:../../advanced/robustness.html[The Robustness of Apache Tika] - Understanding parser risks and mitigations
* https://tika.apache.org/security-model.html[Apache Tika Security Model] - Trust boundaries and assumptions

If you still need to use parsers directly, your application is responsible for
implementing its own process isolation so that you can:

* Set parse timeouts (Tika cannot enforce timeouts without process isolation)
* Configure memory limits (requires separate JVM)
* Kill runaway processes
* Recover from crashes

Never run Tika in the same JVM as critical infrastructure.
